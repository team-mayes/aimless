import logging
import os
import random
from shlex import shlex
import shutil
from string import Template
import sys
import time
import datetime
import math
from common import STATES, enum
from torque import TorqueJob, TorqueSubmissionHandler, is_running

# Constants #
DEF_WAIT_SECS = 10
TSTAMP_FMT = '%Y-%m-%d %H:%M:%S'
FLOAT_FMT = " % 11.7f"

# Basin Constants #
# Three possible basin results
BRES = enum(A='a', B='b', INCONCLUSIVE='i')
BASIN_FWD_KEY = 'forward'
BASIN_BACK_KEY = 'backward'
RC1_FWD_KEY = 'RC1fw'
RC1_BACK_KEY = 'RC1bw'
RC2_FWD_KEY = 'RC2fw'
RC2_BACK_KEY = 'RC2bw'
RC1_LOW_A_KEY = 'RC1loA'
RC1_HIGH_A_KEY = 'RC1hiA'
RC2_LOW_A_KEY = 'RC2loA'
RC2_HIGH_A_KEY = 'RC2hiA'
RC1_LOW_B_KEY = 'RC1loB'
RC1_HIGH_B_KEY = 'RC1hiB'
RC2_LOW_B_KEY = 'RC2loB'
RC2_HIGH_B_KEY = 'RC2hiB'

# Shooter Resources #
XONE_RST = "x1.rst"
XTWO_RST = "x2.rst"
SHOOTER_RST = "shooter.rst"
FWD_RST_NAME = "forward.rst"
BACK_RST_NAME = "backward.rst"
POSTDT_RST_NAME = "postdt.rst"
POSTFWD_RST_NAME = "postforward.rst"
POSTBACK_RST_NAME = "postbackward.rst"
AMBER_JOB_TPL = 'amber_job.tpl'
OUT_DIR = 'output'

# Constant Files #
BACK_CONS_NAME = "cons_back.dat"
FWD_CONS_NAME = "cons_fwd.dat"
DT_CONS_NAME = "cons_dt.dat"

# Directional Input Files #
BACK_IN_NAME = "inbackward.in"
FWD_IN_NAME = "inforward.in"
DT_IN_NAME = "indt.in"
STARTER_IN_NAME = "instarter.in"

# Directional Output Files #
BACK_OUT_NAME = "backward.out"
FWD_OUT_NAME = "forward.out"
DT_OUT_NAME = "dt.out"
STARTER_OUT_NAME = "starter.out"

# MDCRD Files #
BACK_MDCRD_NAME = "backward.mdcrd"
FWD_MDCRD_NAME = "forward.mdcrd"
DT_MDCRD_NAME = "dt.mdcrd"
STARTER_MDCRD_NAME = "starter.mdcrd"

# Config Keys #
NUM_PATHS_KEY = 'numpaths'
TOTAL_STEPS_KEY = 'totalsteps'
BW_STEPS_KEY = 'bwsteps'
FW_STEPS_KEY = 'fwsteps'
DT_STEPS_KEY = 'dtsteps'
BW_OUT_KEY = 'bwout'
FW_OUT_KEY = 'fwout'
DT_OUT_KEY = 'dtout'
TOPO_KEY = 'topology'
COORDS_KEY = 'coordinates'
SHOOTER_KEY = 'shooter'
DIR_RST_KEY = 'dir_rst'
MDCRD_KEY = 'mdcrd'
NUMNODES_KEY = 'numnodes'
NUMCPUS_KEY = 'numcpus'
WALLTIME_KEY = 'walltime'
MAIL_KEY = 'mail'
INFILE_KEY = 'infile'
OUTFILE_KEY = 'outfile'
MDCRD_KEY = 'mdcrd'

# Cleanup #
# Files generated by a path run
GEN_FILES = [BACK_OUT_NAME, FWD_OUT_NAME, DT_OUT_NAME, STARTER_OUT_NAME,
             BACK_MDCRD_NAME, FWD_MDCRD_NAME, DT_MDCRD_NAME, STARTER_MDCRD_NAME,
             BACK_CONS_NAME, FWD_CONS_NAME, DT_CONS_NAME]

logger = logging.getLogger("aimless")

# Exceptions #
class TemplateError(Exception):
    pass


class EnvError(Exception):
    pass

# Logic #

def calc_params(total_steps):
    """Returns a dict with calculated values based on the given number of total
    steps.
    """
    results = {TOTAL_STEPS_KEY: total_steps}
    results[BW_STEPS_KEY] = total_steps / 2
    results[FW_STEPS_KEY] = total_steps / 2
    results[DT_STEPS_KEY] = total_steps / 100
    results[BW_OUT_KEY] = results[BW_STEPS_KEY] - 1
    results[FW_OUT_KEY] = results[FW_STEPS_KEY] - 1
    results[DT_OUT_KEY] = results[DT_STEPS_KEY] - 1
    return results

# Associates the template with the target file name and a description of its purpose.
TPL_LIST = [
    ("cons.tpl", "cons.rst",
     "force constants are zero - this is just to get final bond lengths"),
    ("instarter.tpl", STARTER_IN_NAME,
     "generate the velocities for this shooting point"),
    ("indt.tpl", DT_IN_NAME, "Change in time for the trajectory"),
    ("inforward.tpl", FWD_IN_NAME, "forward portion of the trajectory"),
    ("inbackward.tpl", BACK_IN_NAME, "backward portion of the trajectory"),
]

def write_tpl_files(tpl_dir, tgt_dir, params):
    """Writes the templates in tpl_dir to tgt_dir using params as the source
    for template values

    tpl_dir -- The directory containing the templates.
    tgt_dir -- The target directory for the filled templates.
    params -- A dict of parameters to use when filling the templates.
    """
    for tpl_name, tgt_name, tpl_desc in TPL_LIST:
        tpl_loc = os.path.join(tpl_dir, tpl_name)
        try:
            with open(tpl_loc, 'r') as tpl_file:
                tpl = Template(tpl_file.read())
                result = tpl.safe_substitute(params)
                tgt_loc = os.path.join(tgt_dir, tgt_name)
                try:
                    with open(tgt_loc, 'w') as tgt_file:
                        tgt_file.write(result)
                except (OSError, IOError) as e:
                    raise EnvError(
                        "Couldn't write target '%s': %s" % (tgt_loc, e))
        except (OSError, IOError) as e:
            raise TemplateError(
                "Couldn't read template '%s' (this template creates '%s' for '%s'): %s" % (
                    tpl_loc, tgt_name, tpl_desc, e))

def init_dir(tgt_dir, coords_loc):
    """Copies the coordinates location to x1 and x2."""
    shutil.copy2(coords_loc, os.path.join(tgt_dir, XONE_RST))
    shutil.copy2(coords_loc, os.path.join(tgt_dir, XTWO_RST))

def write_report(pres, tgt=sys.stdout):
    """Creates a human-readable plain text report for the given path results.

    Positional arguments:
    pres -- The path results.
    Keyword arguments:
    tgt -- The target to write to (stdout by default)
    """
    # TODO: Write report
    pass

class AimlessShooter(object):
    """Encapsulates the process of running and analyzing compute jobs related
    to the Aimless Shooting modeling technique.
    """

    def __init__(self, tpl_dir, tgt_dir, topo_loc, job_params, basins_params,
                 sub_handler=TorqueSubmissionHandler(), out=sys.stdout,
                 wait_secs=DEF_WAIT_SECS):
        """Sets up the initial state for this instance.

        Positional Arguments:
        tpl_dir -- The directory containing the templates.
        tgt_dir -- The working directory for this calculation.
        topo_loc -- Location of the topology file.
        job_params -- Dict of parameters used for filling in the Amber job
                      templates.
        basins_params -- Dict of parameters used for running basin calculations.
        Keyword Arguments:
        sub_handler -- The submission handler for jobs (defaults to
                        TorqueSubmissionHandler)
        out -- The target for output (defaults to stdout)
        wait_secs -- The length of time to wait while polling jobs (defaults to
                     10 seconds).
        """
        self.tgt_dir = tgt_dir
        self.tpl_dir = tpl_dir
        self.topo_loc = topo_loc
        self.job_params = job_params
        self.bp = basins_params
        self.sub_handler = sub_handler
        self.out = out
        self.wait_secs = wait_secs
        self.x1_loc = self.tgtres(XONE_RST)
        self.x2_loc = self.tgtres(XTWO_RST)

    def run_calcs(self, num_paths):
        """Top-level runner for performing the aimless shooting calculations
        for the given number of paths, returning the results.

        Positional arguments:
        num_paths -- The number of paths to run.
        Returns:
        A nested dict keyed first by path, then by 'forward' and 'backward',
        with the values being the result of calc_basins for each path.
        """
        pres = {}
        for pnum in range(1, num_paths + 1):
            if random.randint(0, 1):
                shooter = self.x1_loc
            else:
                shooter = self.x2_loc
            self.out.write("Using '%s'\n" % shooter)
            self.run_starter(pnum, shooter)
            self.rev_vel()
            self.run_dt()
            self.run_fwd_and_back()
            pres[pnum] = self.calc_basins()
            self.proc_results(pres[pnum], shooter)
            self.clean(pnum)
        return pres

    def run_starter(self, pnum, shooter):
        """Runs the starter job, backing up the generated forward file.
        Returns when the submitted job is finished.

        pnum -- The path number currently running.
        shooter -- The chosen shooter file for this path.
        """
        self.out.write('running starter... generating velocities\n')
        start_id = self._sub_job(shooter,
                                 self.tgtres(FWD_IN_NAME),
                                 self.tgtres(STARTER_IN_NAME),
                                 self.tgtres(STARTER_OUT_NAME),
                                 self.tgtres(STARTER_MDCRD_NAME),
        )
        self._wait_on_jobs([start_id])
        # Back up fwd rst
        path_out_dir = self.tgtres(OUT_DIR, str(pnum))
        if not os.path.exists(path_out_dir):
            os.makedirs(path_out_dir)
        shutil.copy2(self.tgtres(FWD_RST_NAME), path_out_dir)

    def rev_vel(self):
        """Generates the backward.rst file based on the contents of forward.rst.
        """
        self.out.write('reversing velocities\n')
        fwd_loc = self.tgtres(FWD_RST_NAME)
        back_loc = self.tgtres(BACK_RST_NAME)
        with open(fwd_loc) as fwd_file:
            fwd_lines = [line.rstrip('\n') for line in fwd_file]
        with open(back_loc, 'w') as back_file:
            back_file.write(fwd_lines[0].split()[0])
            back_file.write(" Made by %s at %s\n" % (os.path.basename(__file__),
                                                     datetime.datetime.now().
                                                     strftime(TSTAMP_FMT)))
            back_file.write(fwd_lines[1] + os.linesep)
            num_atoms = float(fwd_lines[1].split()[0])
            # Atom coordinates are two per line
            coord_lines = int(math.ceil(num_atoms / 2.0))
            # Don't touch the coordinates
            for sameline in range(2, coord_lines + 2):
                back_file.write(fwd_lines[sameline] + os.linesep)
                #Reverse the velocities
            for revline in range(2 + coord_lines, (coord_lines * 2) + 2):
                fline = map(float, fwd_lines[revline].split())
                back_file.write("".join(FLOAT_FMT % -num for num in fline))
                back_file.write(os.linesep)
                # Write out last line
            back_file.write(fwd_lines[-1])

    def calc_basins(self):
        """Performs the basin calculations for the current forward and bad
        backward cons data files.

        Returns a dict with the results (a, b, or i) keyed to 'forward'
        and 'backward'.  The results also contain 'RC1fw', 'RC1bw', 'RC2fw',
        and 'RC2bw'.
        """
        results = {}
        fwd_loc = self.tgtres(FWD_CONS_NAME)
        back_loc = self.tgtres(BACK_CONS_NAME)
        with open(fwd_loc) as fwd_file:
            fwd_lines = [line.rstrip('\n') for line in fwd_file]
        with open(back_loc) as back_file:
            back_lines = [line.rstrip('\n') for line in back_file]
        discard, results[RC1_FWD_KEY], results[RC2_FWD_KEY] = \
            map(float, fwd_lines[1].split())
        discard, results[RC1_BACK_KEY], results[RC2_BACK_KEY] = \
            map(float, back_lines[1].split())
        results[BASIN_FWD_KEY] = self.find_basin_dir(results[RC1_FWD_KEY],
                                                     results[RC2_FWD_KEY])
        results[BASIN_BACK_KEY] = self.find_basin_dir(results[RC1_BACK_KEY],
                                                      results[RC2_BACK_KEY])
        return results

    def run_dt(self):
        """Submits the DT job. Returns when the submitted job is finished.
        """
        self.out.write('running dt\n')
        start_id = self._sub_job(self.tgtres(FWD_RST_NAME),
                                 self.tgtres(POSTDT_RST_NAME),
                                 self.tgtres(DT_IN_NAME),
                                 self.tgtres(DT_OUT_NAME),
                                 self.tgtres(DT_MDCRD_NAME),
        )
        self._wait_on_jobs([start_id])

    def run_fwd_and_back(self):
        """Submits the forward and backward jobs concurrently. Returns when
        the submitted jobs are finished.
        """
        self.out.write('running forward\n')
        fwd_id = self._sub_job(self.tgtres(POSTDT_RST_NAME),
                               self.tgtres(POSTFWD_RST_NAME),
                               self.tgtres(FWD_IN_NAME),
                               self.tgtres(FWD_OUT_NAME),
                               self.tgtres(FWD_MDCRD_NAME),
        )

        self.out.write('running backward\n')
        back_id = self._sub_job(self.tgtres(POSTFWD_RST_NAME),
                                self.tgtres(POSTBACK_RST_NAME),
                                self.tgtres(BACK_IN_NAME),
                                self.tgtres(BACK_OUT_NAME),
                                self.tgtres(BACK_MDCRD_NAME),
        )
        self._wait_on_jobs([fwd_id, back_id])

    def _wait_on_jobs(self, job_ids):
        """Polls the state of the given job IDs.  Returns when the IDs
        disappear from the status dict or the job's status is 'complete'.

        job_ids -- The list of IDs to wait for.
        """
        jstats = self.sub_handler.stat_jobs(job_ids)
        wait_count = 1
        while is_running(job_ids, jstats):
            self.out.write("Waiting '%d' seconds for job IDs '%s'\n" %
                           (wait_count * self.wait_secs, ",".join(map(str, job_ids))))
            time.sleep(self.wait_secs)
            wait_count += 1
            jstats = self.sub_handler.stat_jobs(job_ids)
        self.out.write("Finished job IDs '%s' in '%d' seconds\n" %
                       (",".join(map(str, job_ids)), (wait_count - 1) * self.wait_secs))

    def _sub_job(self, shooter_loc, dir_rst_loc, in_loc, out_loc, mdcrd_loc):
        """Fills the job template with the given parameters and submits the
        job, returning the ID assigned to the job.

        Positional arguments:
        shooter_loc -- The location of the "shooter" file
        dir_rst_loc -- The location of the <direction>.rst file to use
        in_loc -- The location of the input file
        out_loc -- The location of the output file
        mdcrd_loc -- The location of the mdcrd file
        Returns:
        The ID of the submitted job
        """
        local_params = self.job_params.copy()
        local_params[TOPO_KEY] = self.topo_loc
        local_params[SHOOTER_KEY] = shooter_loc
        local_params[DIR_RST_KEY] = dir_rst_loc
        local_params[INFILE_KEY] = in_loc
        local_params[OUTFILE_KEY] = out_loc
        local_params[MDCRD_KEY] = mdcrd_loc

        tpl_loc = os.path.join(self.tpl_dir, AMBER_JOB_TPL)
        with open(tpl_loc, 'r') as tpl_file:
            tpl = Template(tpl_file.read())
            result = tpl.safe_substitute(local_params)
        job = TorqueJob(**local_params)
        logger.info("Submitting:\n%s" % result)
        job.contents = result
        return self.sub_handler.submit(job)

    def tgtres(self, *args):
        """Alias for resolving the given path segments against the target
        directory.
        """
        return os.path.join(self.tgt_dir, *args)

    def find_basin_dir(self, rc1, rc2):
        """Determines whether the given reaction coordinates are going toward
        A, B, or neither (inconclusive).

        Positional arguments:
        rc1 -- The first reaction coordinate.
        rc2 -- The second reaction coordinate.
        Returns:
        a, b, or i depending on which basin (if any) matches.
        """
        if self.bp[RC1_LOW_A_KEY] < rc1 < self.bp[RC1_HIGH_A_KEY] \
            and self.bp[RC2_LOW_A_KEY] < rc2 < self.bp[RC2_HIGH_A_KEY]:
            return BRES.A
        elif self.bp[RC1_LOW_B_KEY] < rc1 < self.bp[RC1_HIGH_B_KEY] \
            and self.bp[RC2_LOW_B_KEY] < rc2 < self.bp[RC2_HIGH_B_KEY]:
            return BRES.B
        else:
            return BRES.INCONCLUSIVE

    def proc_results(self, result, shooter):
        """

        """
        if (result[BASIN_FWD_KEY] == BRES.A and result[BASIN_BACK_KEY] ==
            BRES.B) or (result[BASIN_FWD_KEY] == BRES.B
                        and result[BASIN_BACK_KEY] == BRES.A):
            shutil.copy2(shooter, self.x1_loc)
            shutil.copy2(self.tgtres(POSTDT_RST_NAME), self.x2_loc)

    def clean(self, pnum):
        path_out_dir = self.tgtres(OUT_DIR, str(pnum))
        for mvname in GEN_FILES:
            tgt = self.tgtres(mvname)
            try:
                shutil.move(tgt, path_out_dir)
            except Exception, e:
                print(e)
                logger.warn("Could not archive '%s' as it doesn't exist" % path_out_dir)